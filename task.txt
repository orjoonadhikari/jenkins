-> Create a Shell script in which perform the below opeations :- 

a) Take a username input from user and if it not exist, then create it.
b) If user not exist, then create it with their home directory.
c) Newly Created User should have bin/bash Shell.
d) if User exist, then print the Message User already exist.\

================================================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>	AWS		<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
================================================================================================

Task :- 

Create a Application Load Balancer in which we have 1 Target Group having two Web Servers.

-> 1st Server having webpage :- Welcome to 1st Demo Server
-> 2nd Server having Webpage :- Welcome to 2nd Demo Server

Then Use the DNS Name of ALB and put it in the Browser to check
the Load Balancing between the Servers.
............................................................................................................
-> Create a BucketName with your names3demo-dateofbirth and upload a image of your choice.
-> Access this Image in Internet World.
----------------------------------------------------------------------------------------
2  apt update
    3  apt install awscli
    4  cat /etc/os-release
    5  aws configure
    6  cat ~/.aws/credentials
    7  aws s3 ls
    8  aws s3 ls s3://testvikas1234
    9  aws s3 mb s3://devops2401
   10  aws s3 rb s3://devops2401
   11  kls
   12  ls
   13  cd /opt/
   14  ls
   15  echo bucket-file > bucket.txt
   16  aws s3 cp bucket.txt s3://testvikas1234
   17  aws s3 rm  s3://testvikas1234/bucket.txt
   18  history
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   21  aws ec2 describe-instances | jq -r '.Reservations[].Instances[]|.InstanceId+" "+.InstanceType+" "+(.Tags[] | select(.Key == "Name").Value)'
   22  aws --region=us-east-2 ec2 describe-instances | jq -r '.Reservations[].Instances[]|.InstanceId+" "+.InstanceType+" "+(.Tags[] | select(.Key == "Name").Value)'
   23  aws --region=us-east-2 ec2 describe-instances --query 'Reservations[*].Instances[?not_null(PublicIpAddress)]' | jq -r '.[][]|.PublicIpAddress+" "+(.Tags[]|select(.Key=="Name").Value)'
   24  aws --region=us-east-2 ec2 describe-instances --instance-ids i-054f8c409fbd2d2f5 | jq -r '.Reservations[].Instances[].SecurityGroups[]|.GroupId+" "+.GroupName'
   25  aws --region=us-east-2 ec2 describe-instances --instance-ids i-0c70967c669a615e4 | jq -r '.Reservations[].Instances[].SecurityGroups[]|.GroupId+" "+.GroupName'
   26  history
   ---------------------------------------------------------------------------
   ============================================================================================================
   1) Create the  Users in IAM with the below Name and Permissions :- 

-> DevOps User -> ec2 read only access
-> S3 User -> s3 full access.

Apply the different operations on s3 and ec2 using awscli Commands from your Local System.
e.g. 
-> Get the EC2 Name with Instance Id.
-> Create and Remove S3 Bucket, Upload and remove s3 object.
==================================================================================================================
1) Create a master Branch having a file master.txt with content hello master branch.

1.1) Create a Branch name dev having a file dev.txt and merge this 
branch with master Branch.
1.2) Create a Branch qa branch having a file qa.txt and merge this
branch with dev branch
1.3) Create a Branch staging branch having a file staging.txt and merge this
branch with qa branch
/////////////////////////////////////////////////////////////////////////////////////////////
Docker---
		Note :- Create the EC2 Server and Install the docker engine on the same.
	1) Run the Nginx Container on port-8081 and having name:- your_name-nginx
	2) Run the Apache(httpd) Container Parallely with Nginx on port-8082 and having name your_name-apache
	3) Stop and Start the Nginx Conatiner and Output should be 8081 and 8082 respectively.
	4) Remove the Container and Image which was created Above.
	
Task :- 

-> 1) Create a Dockerfile in which install the nginx and curl package etc.

a) Run the web page on port 81 and output will be 81

Make the changes only in Dockerfile and perform the below task.
b) Run the web page on port 82 and output will be 82

In above scenarios, no need to login into the Conatiners.


->  2) Write a Shell Script which includes to make changes in Dockerfile for  web-page only which can be taken as input.

a) Run the Dockerfile with fixed tag_name.
b) Run container only on port 83.
================================================================================
Task :- 
Blind mount
-> Create a Conatiner of Nginx and mount the nginx logs(/var/log/nginx)
on host filesystem having the path /var/log/container_name.

No need to login into Conatiner to check the real time logs.
Once you checked the logs then Remove the running nginx Conatiner and again
check the logs, it must be exist on your Host filesystem.

===============================================================================
Task :-

Create a Docker compose file in which link the mysql Database with nginx container.

-> Ensure that Both Containers are able to connect on their specific ports.
-> Using curl commands, check the nginx container output and logs parallely on other terminal.


/////////////
Write a Dockerfile to run the python app on host port 5000.   --> Dockerfile + python app deploy
root@Docker:~/python-app-deploy# ls
Dockerfile  app.py  python-app-deploy.sh  requirements.txt
root@Docker:~/python-app-deploy# cat app.py

from flask import Flask

app = Flask(__name__)

@app.route('/')
def hello():
    return 'Python App is working now'

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=80)
root@Docker:~/python-app-deploy# cat requirements.txt
flask
root@Docker:~/python-app-deploy# cat Dockerfile

FROM python:3-alpine

COPY requirements.txt .
COPY app.py .

RUN pip install -r requirements.txt

EXPOSE 80


ENTRYPOINT ["python3", "app.py"]
root@Docker:~/python-app-deploy#
/////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Task :-

Create a Docker compose file in which link the mysql Database with nginx container.

-> Ensure that Both Containers are able to connect on their specific ports.
-> Using curl commands, check the nginx container output and logs parallely on other terminal.


Write a Dockerfile to run the python app on host port 5000.   --> Dockerfile + python app deploy
==========================================================================================================
Task :- >>>>> kubernetes >>>>>>


1) Create a Namespace with your own name and also create the pod with image redis
inside this Namespace.
			$kubectl create ns arjun
			$kubectl run arjun --image=redis -n=arjun

2) List the Running pod and store the output of this pod in yaml file,
then delete the running pod and redeploy the pod again using yaml file.
			$kubectl get pod -A
			$kubectl get pod -n=arjun -o yaml > pod.yaml
			$kubectl delete pod arjun -n=arjun
			$kubectl apply -f pod.yaml
			 

3) List all Pods which is running in specific namespaces.
			$kubectl get pod -n=arjun

4) Create a pod having image redis and scheduled it on running worker node.
				$ ( make vi file ).yaml
				$ kubectl apply -f  ( make vi file ).yaml
				

5)  Create a Pod name nginx_label_pod having image redis and select the worker node
	labels.
				$ need to do


======================================================================================
09-12-2023

-> You already having the multi nodes config in K8s Cluster in which 1 is master node and 2 is worker node.

Apply the taint effect on Master Node having values -> app=backend:NoSchedule

Now, Perform the below task :- 

a) Schedule the Pod without toleration effect.
b) Scheduled the Pod with toleration effect.


->Create a Static pod in node-2 worker node having nginx container running.



-> Create a deployment file having replicas 2 of nginx image in which pass the env variables having values :- 
devops=your_own_name
===================================================================================================================
Task :- 

-> Create a Secret Name ie. yourname-creds  having values :- 
    Username -> yourname
    Password -> yourname@123

-> Create a redis Pod and mount the above secret name on path /etc/yourname.
-> Kindly Verify the Username and Password in the running Pod.
======================================================================================================================
